apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-app-code
  labels:
    app: {{ .Release.Name }}-app
    {{- include "ospo-app.labels" . | nindent 4 }}
data:
  # Application configuration file
  package.json: |-
    {
      "name": "ospo-events-app",
      "version": "1.0.0",
      "main": "server/dist/index.js",
      "scripts": {
        "start": "node server/dist/index.js",
        "dev": "NODE_ENV=development tsx server/index.ts",
        "build": "vite build"
      },
      "dependencies": {
        "express": "^4.18.2",
        "@neondatabase/serverless": "^0.6.0",
        "drizzle-orm": "^0.28.1",
        "express-session": "^1.17.3",
        "express-fileupload": "^1.4.0",
        "passport": "^0.7.0",
        "passport-local": "^1.0.0",
        "keycloak-connect": "^22.0.3",
        "keycloak-js": "^22.0.3",
        "ws": "^8.13.0",
        "zod": "^3.22.2"
      }
    }
  # Shared schema file
  shared_schema.js: |-
    // Database schema for the application
    const { pgTable, varchar, text, integer, timestamp, serial } = require('drizzle-orm/pg-core');
    
    // Events table
    exports.events = pgTable('events', {
      id: serial('id').primaryKey(),
      name: varchar('name', { length: 255 }).notNull(),
      location: varchar('location', { length: 255 }),
      startDate: varchar('start_date', { length: 30 }),
      endDate: varchar('end_date', { length: 30 }),
      type: varchar('type', { length: 50 }),
      goals: text('goals'),
      budget: integer('budget'),
      notes: text('notes'),
      createdAt: timestamp('created_at').defaultNow(),
      updatedAt: timestamp('updated_at').defaultNow()
    });
    
    // Users table
    exports.users = pgTable('users', {
      id: serial('id').primaryKey(),
      keycloakId: varchar('keycloak_id', { length: 100 }),
      username: varchar('username', { length: 100 }).notNull(),
      email: varchar('email', { length: 255 }),
      name: varchar('name', { length: 255 }),
      jobTitle: varchar('job_title', { length: 100 }),
      headshotUrl: varchar('headshot_url', { length: 255 }),
      createdAt: timestamp('created_at').defaultNow(),
      updatedAt: timestamp('updated_at').defaultNow()
    });
    
    // CFP Submissions table
    exports.cfpSubmissions = pgTable('cfp_submissions', {
      id: serial('id').primaryKey(),
      eventId: integer('event_id').notNull(),
      title: varchar('title', { length: 255 }).notNull(),
      abstract: text('abstract'),
      submitterId: integer('submitter_id').notNull(),
      submitterName: varchar('submitter_name', { length: 255 }),
      status: varchar('status', { length: 50 }).default('submitted'),
      submissionDate: varchar('submission_date', { length: 30 }),
      notes: text('notes'),
      createdAt: timestamp('created_at').defaultNow(),
      updatedAt: timestamp('updated_at').defaultNow()
    });
    
    // Assets table
    exports.assets = pgTable('assets', {
      id: serial('id').primaryKey(),
      name: varchar('name', { length: 255 }).notNull(),
      type: varchar('type', { length: 50 }).notNull(),
      filePath: varchar('file_path', { length: 255 }).notNull(),
      fileSize: integer('file_size'),
      mimeType: varchar('mime_type', { length: 100 }),
      uploadedBy: integer('uploaded_by'),
      uploadedByName: varchar('uploaded_by_name', { length: 255 }),
      eventId: integer('event_id'),
      cfpSubmissionId: integer('cfp_submission_id'),
      description: text('description'),
      uploadedAt: timestamp('uploaded_at').defaultNow()
    });

  # Server entry point file
  server_dist_index.js: |-
    const express = require('express');
    const fileUpload = require('express-fileupload');
    const fs = require('fs');
    const path = require('path');
    const { Pool } = require('@neondatabase/serverless');
    const { drizzle } = require('drizzle-orm/neon-serverless');
    const schema = require('../shared/schema');
    const ws = require('ws');
    
    // Initialize Express app
    const app = express();
    const PORT = process.env.PORT || 5000;
    
    // Database connection
    let pool, db;
    try {
      if (process.env.DATABASE_URL) {
        // Configure WebSocket for Neon PostgreSQL
        neonConfig.webSocketConstructor = ws;
        
        // Connect to PostgreSQL database
        pool = new Pool({ connectionString: process.env.DATABASE_URL });
        db = drizzle(pool, { schema });
        console.log('Connected to PostgreSQL database');
      } else {
        console.warn('No DATABASE_URL provided, running in database-less mode');
      }
    } catch (err) {
      console.error('Error connecting to database:', err);
    }
    
    // App middleware
    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));
    
    // File upload middleware
    app.use(fileUpload({
      limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
      useTempFiles: true,
      tempFileDir: '/tmp/',
      createParentPath: true
    }));
    
    // Static file serving for the client app
    app.use(express.static(path.join(__dirname, '../../public')));
    
    // Health check endpoint
    app.get('/api/health', (req, res) => {
      res.json({
        status: 'healthy',
        version: '1.0.0',
        timestamp: new Date().toISOString(),
        database: db ? 'connected' : 'not connected'
      });
    });
    
    // Basic events API
    app.get('/api/events', async (req, res) => {
      try {
        if (db) {
          const result = await db.select().from(schema.events);
          res.json(result);
        } else {
          res.status(503).json({ error: 'Database not available' });
        }
      } catch (err) {
        console.error('Error fetching events:', err);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    // Event by ID endpoint
    app.get('/api/events/:id', async (req, res) => {
      try {
        if (db) {
          const id = parseInt(req.params.id);
          const result = await db.select().from(schema.events).where(eq(schema.events.id, id));
          if (result.length === 0) {
            return res.status(404).json({ error: 'Event not found' });
          }
          res.json(result[0]);
        } else {
          res.status(503).json({ error: 'Database not available' });
        }
      } catch (err) {
        console.error('Error fetching event:', err);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    // All other API routes would be defined here...
    
    // SPA fallback for client-side routing
    app.get('*', (req, res) => {
      // Exclude API routes from the fallback
      if (!req.path.startsWith('/api/')) {
        return res.sendFile(path.join(__dirname, '../../public/index.html'));
      }
      res.status(404).json({ error: 'API endpoint not found' });
    });
    
    // Global error handler
    app.use((err, req, res, next) => {
      console.error('Unhandled error:', err);
      res.status(500).json({
        error: 'Internal server error',
        message: process.env.NODE_ENV === 'production' ? undefined : err.message
      });
    });
    
    // Start the server
    app.listen(PORT, '0.0.0.0', () => {
      console.log(`OSPO Events App server running on port ${PORT}`);
    });
    const session = require('express-session');
    const { Pool } = require('@neondatabase/serverless');
    const { drizzle } = require('drizzle-orm/neon-serverless');
    
    // Create Express application
    const app = express();
    const port = process.env.PORT || 5000;
    
    // Configure JSON and uploads middleware
    app.use(express.json());
    app.use(express.urlencoded({ extended: true }));
    app.use(fileUpload({
      limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
      createParentPath: true,
      useTempFiles: true,
      tempFileDir: '/tmp/'
    }));
    
    // Create uploads directory
    const uploadsDir = path.join(__dirname, '../../public/uploads');
    if (!fs.existsSync(uploadsDir)) {
      fs.mkdirSync(uploadsDir, { recursive: true });
    }
    
    // Serve static files
    app.use(express.static(path.join(__dirname, '../../public')));
    app.use(express.static(path.join(__dirname, '../../dist')));
    
    // Session configuration
    app.use(session({
      secret: process.env.SESSION_SECRET || 'development-secret',
      resave: false,
      saveUninitialized: true,
      cookie: { secure: process.env.NODE_ENV === 'production' }
    }));
    
    // Database configuration
    let db;
    try {
      if (process.env.DATABASE_URL) {
        const pool = new Pool({ connectionString: process.env.DATABASE_URL });
        db = drizzle(pool);
        console.log('Connected to PostgreSQL database');
      } else {
        console.warn('No DATABASE_URL provided, operating in database-less mode');
      }
    } catch (error) {
      console.error('Database connection error:', error);
    }
    
    // API Routes
    
    // Health check endpoint
    app.get('/api/health', (req, res) => {
      res.json({
        status: 'healthy',
        timestamp: new Date().toISOString(),
        service: 'ospo-app',
        version: '1.0.0',
        database: db ? 'connected' : 'not-connected'
      });
    });
    
    // Get all events
    app.get('/api/events', async (req, res) => {
      console.log('GET /api/events called');
      try {
        if (db) {
          // We would query the database here
          const events = await getEventsFromDb();
          res.json(events);
        } else {
          // Return sample data in DB-less mode
          res.json([
            { id: 1, name: 'Sample Event 1', location: 'San Francisco', startDate: '2025-06-01' },
            { id: 2, name: 'Sample Event 2', location: 'New York', startDate: '2025-07-15' }
          ]);
        }
      } catch (error) {
        console.error('Error fetching events:', error);
        res.status(500).json({ error: 'Internal server error' });
      }
    });
    
    // Catch-all handler for SPA frontend routing
    app.get('*', (req, res) => {
      res.sendFile(path.join(__dirname, '../../dist', 'index.html'));
    });
    
    // Sample function for database access
    async function getEventsFromDb() {
      if (!db) return [];
      try {
        // This is a placeholder - real implementation would use
        // schema-specific queries with the actual table name
        const result = await db.query.select().from({ schema: 'public', name: 'events' });
        return result.rows;
      } catch (error) {
        console.error('Database query error:', error);
        return [];
      }
    }
    
    // Start the server
    app.listen(port, '0.0.0.0', () => {
      console.log(`Server running on port ${port}`);
    });